/**
 * Ginstr Lang: BNF Grammar.
 */

%{

/**
 * Creates generic binary expression node.
 */
function BinaryExpression(left, operator, right) {
  return {
    type: 'BinaryExpression',
    operator,
    left,
    right
  };
}

/**
 * Creates generic binary expression node.
 */
function MathExpression(fn, args) {
  return {
    type: 'BinaryExpression',
    operator,
    left,
    right
  };
}

/**
 * Creates logical expression node.
 */
function LogicalExpression(left, operator, right) {
  return {
    type: 'LogicalExpression',
    operator,
    left,
    right
  };
}

/**
 * Creates an unary expression node.
 */
function UnaryExpression(operator, argument) {
  return {
    type: 'UnaryExpression',
    operator,
    argument,
  };
}

/**
 * Creates a literal node.
 */
function Literal(value) {
  return {
             type: 'Literal',
             value: value,
             raw: value
           };
}

/**
 * Creates a NumLiteral node.
 */
function NumLiteral(value) {
  return {
    type: 'Literal',
    value: Number(value),
    raw: value
  };
}

/**
 * Creates a StringLiteral node.
 */
function StringLiteral(value) {
  return {
    type: 'Literal',
    value: value,
    raw: "'" + value + "'"
  };
}

/**
 * Creates treanry.
 */
function Ternary(test, consequent, alternate) {
  return {
    type: 'ConditionalExpression',
    test,
    consequent,
    alternate,
  };
}

function ObjectLiteral(properties) {
  enforceObjectProperties(properties);
  return {
    type: 'ObjectExpression',
    properties,
  }
}

/**
 * Since we use cover grammar to parse blocks and objects,
 * this function checks that all entries in a block are
 * object properties.
 */
function enforceObjectProperties(nodes) {
  nodes.forEach(node => {
    if (node.type !== 'Property') {
      throw new Error(
        'ObjectLiteral: invalid property declaration.'
      );
    }
  });
}

/**
 * MemberExpression.
 */
function MemberExpression(object, property) {
  return {
    type: 'MemberExpression',
    computed: property.type !== 'Identifier',
    object,
    property,
  };
}

%}

%%

// Main Program.
Program : ReturnStatement { $$ =  $1 } ;
ReturnStatement
  : OptExpression  OptSemi
    {
      $$ = {
        type: 'ReturnStatement',
        argument: $1,
      }
    }
  ;

OptExpression : Expression | { $$ = null } ;
Expression : AssignmentExpression | TernaryExpression ;
StatementList : Statement { $$ = [$1] } ;
Statement : EmptyStatement | ExpressionStatement ;
EmptyStatement :  { $$ = { type: 'EmptyStatement' } } ;

/**
 * BlockOrObject.
 *
 * Cover grammar: { } at statement position should be parsed as a Block,
 * however at expression position should be parsed as ObjectLiteral.
 *
 * We could use lookahead restrictions by doubling the expression
 * productions (using "NoCurly" version of expression productions) in order
 * to parse `ExpressionStatement` correctly, however we choose here to use
 * cover grammar with single `BlockOrObject` production, and enforcing
 * needed nodes (object properties or statement list) based on the
 * statement or expression position.
 */
BlockOrObject
  : LCURLY OptBlockOrObjectEntries RCURLY
    { $$ = $2 }
  ;

/**
 * OptBlockOrObjectEntries.
 *
 * Cover grammar: see `BlockOrObject`.
 */
OptBlockOrObjectEntries
  : PropertyList OptComma
    { $$ = $1 }

  | /* empty */
    { $$ = [] }
  ;


/**
 * Optional Identifier.
 */
OptIdentifier
  : Identifier
  | /* empty */ { $$ = null }
  ;

/**
 * OptFormalParameterList.
 */
OptFormalParameterList
  : FormalParameterList
  | /* empty */ { $$ = [] }
  ;

/**
 * FormalParameterList.
 */
FormalParameterList
  : Identifier
    { $$ = [$1] }

  | FormalParameterList COMMA Identifier
    { $1.push($3); $$ = $1 }
  ;

/**
 * Ternary.
 */
TernaryExpression
  : Expression QUESTION Expression COLON Expression
    { $$ = Ternary($1, $3, $5) }
  ;

/**
 * ExpressionStatement.
 */
ExpressionStatement
  : Expression
    {
      $$ = {
        type: 'ExpressionStatement',
        expression: $1,
      }
    }
  ;

/**
 * Literal (numbers, and strings).
 */
Literal
  : STRING { $$ = StringLiteral($1) }
  | NUMBER { $$ = NumLiteral($1) }
  | TRUE   { $$ = Literal(true) }
  | FALSE  { $$ = Literal(false) }
  | NULL   { $$ = Literal(null) }
  ;

/**
 * Primary expression.
 */
PrimaryExpression
  : MemberExpression
  | Literal
  | ObjectLiteral
  ;

/**
 * OptElementList.
 */
OptElementList
  : ElementList OptComma
    { $$ = $1 }

  | /* empty */
    { $$ = [] }
  ;

OptComma : COMMA | /* empty */ { $$ = null } ;
OptSemi : SEMICOLON | { $$ = null } ;



/**
 * ElementList.
 */
ElementList
  : AssignmentExpression
    { $$ = [$1] }

  | ElementList COMMA AssignmentExpression
    { $1.push($3); $$ = $1 }
  ;

/**
 * ObjectLiteral.
 */
ObjectLiteral
  : BlockOrObject
    { $$ = ObjectLiteral($1) }
  ;

/**
 * PropertyList.
 */
PropertyList
  : PropertyAssignment
    { $$ = [$1] }

  | PropertyList COMMA PropertyAssignment
    { $1.push($3); $$ = $1 }
  ;

/**
 * PropertyAssignment.
 */
PropertyAssignment
  : PropertyName COLON Expression
    {
      $$ = {
        type: 'Property',
        key: $1,
        value: $3,
      }
    }
  ;

/**
 * PropertyName.
 */
PropertyName
  : Literal
  | Identifier
  ;

/**
 * ParenthisizedExpression.
 */
ParenthisizedExpression
  : LPAREN Expression RPAREN { $$ = $2 }
  ;

/**
 * Identifier.
 */
Identifier
  : IDENTIFIER
    { $$ = {
        type: 'Identifier',
        name: $1,
      }
    }
  ;

/**
 * MemberExpression.
 */
MemberExpression
  : MemberExpression LBRACKET Expression RBRACKET
    { $$ = MemberExpression($1, $3)}

  | MemberExpression DOT Identifier
    { $$ = MemberExpression($1, $3)}

  | Identifier
  ;

/**
 * Assignment expression.
 *
 * AssignmentOperator: =, *=, /=, +=, -=,
 *
 * x = y
 * x *= y
 * x /= y
 * x += y
 * x -= y
 */
AssignmentExpression
  : LogicalORExpression
  ;

/**
 * Logical OR expression.
 *
 * x || y
 */
LogicalORExpression
  : LogicalANDExpression
  | LogicalORExpression LOGICAL_OR LogicalANDExpression
      { $$ = LogicalExpression($1, $2, $3) }
  ;

/**
 * Logical AND expression.
 *
 * x && y
 */
LogicalANDExpression
  : EqualityExpression
  | LogicalANDExpression LOGICAL_AND EqualityExpression
      { $$ = LogicalExpression($1, $2, $3) }
  ;

/**
 * Equality expressions.
 *
 * EQUALITY_OPERATOR: ==, !=
 *
 * x == y
 * x != y
 */
EqualityExpression
  : RelationalExpression
  | EqualityExpression EQUALITY_OPERATOR RelationalExpression
      { $$ = BinaryExpression($1, $2, $3) }
  ;

/**
 * Relational expressions.
 *
 * RELATIONAL_OPERATOR: >, >=, <, <=
 *
 * x > y
 * x >= y
 * x < y
 * x <= y
 */
RelationalExpression
  : AdditiveExpression
  | RelationalExpression RELATIONAL_OPERATOR AdditiveExpression
      { $$ = BinaryExpression($1, $2, $3) }
  ;

/**
 * Additive expressions.
 *
 * ADDITIVE_OPERATOR: +, -
 *
 * x + y
 * x - y
 */
AdditiveExpression
  : MultiplicativeExpression
  | AdditiveExpression ADDITIVE_OPERATOR MultiplicativeExpression
      { $$ = BinaryExpression($1, $2, $3) }
  ;

/**
 * Additive expressions.
 *
 * MULTIPLICATIVE_OPERATOR: *, /
 *
 * x * y
 * x / y
 */
MultiplicativeExpression
  : UnaryExpression
  | MultiplicativeExpression MULTIPLICATIVE_OPERATOR UnaryExpression
      { $$ = BinaryExpression($1, $2, $3) }
  ;

/**
 * Unary expression.
 */
UnaryExpression
  : PrimaryExpression
  | ParenthisizedExpression
  | CallExpression
  | ADDITIVE_OPERATOR UnaryExpression
    { $$ = UnaryExpression($1, $2) }
  ;

/**
 * CallExpression.
 */
CallExpression
  : Callee Arguments
    {
      $$ = {
        type: 'CallExpression',
        callee: $1,
        arguments: $2,
      };
    }
  ;

/**
 * Callee.
 *
 * Simple function call `foo();` or chained `foo()();`.
 */
Callee
  : CustomFunctions
  | CallExpression
  ;

/**
 * Call expression arguments.
 */
Arguments
  : LPAREN OptArgumentList RPAREN
    { $$ = $2 }
  ;

/**
 * OptArgumentList.
 */
OptArgumentList
  : ArgumentList
  | /* empty */ { $$ = [] }
  ;

/**
 * ArgumentList.
 */
ArgumentList
  : AssignmentExpression
    { $$ = [$1] }

  | ArgumentList COMMA AssignmentExpression
    { $$ = $1; $1.push($3) }
  ;

CustomExpressions
 : FN
 { $$ = {
     "type": "Identifier",
     "name": $1
     }
 };

CustomFunctions
  : CustomExpressions
  { $$ = MemberExpression({
            "type": "Identifier",
            "name": "fns"
            }, $1)
  } ;